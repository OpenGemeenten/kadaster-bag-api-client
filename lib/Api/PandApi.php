<?php
/**
 * PandApi
 * PHP version 5
 *
 * @category Class
 * @package  Kadaster\BagApiClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * IMBAG API - van de LVBAG
 *
 * Dit is de [BAG API](https://zakelijk.kadaster.nl/-/bag-api) Individuele Bevragingen van de Landelijke Voorziening Basisregistratie Adressen en Gebouwen (LVBAG).  Meer informatie over de Basisregistratie Adressen en Gebouwen is te vinden op de website van het [Ministerie van Binnenlandse Zaken en Koninkrijksrelaties](https://www.geobasisregistraties.nl/basisregistraties/adressen-en-gebouwen) en [Kadaster](https://zakelijk.kadaster.nl/bag).  De BAG API levert informatie conform de [BAG Catalogus 2018](https://www.geobasisregistraties.nl/documenten/publicatie/2018/03/12/catalogus-2018) en het informatiemodel IMBAG 2.0. De API specificatie volgt de [Nederlandse API-Strategie](https://docs.geostandaarden.nl/api/API-Strategie) specificatie versie van 20200204 en is opgesteld in [OpenAPI Specificatie](https://www.forumstandaardisatie.nl/standaard/openapi-specification) (OAS) v3.  Het standaard mediatype HAL (`application/hal+json`) wordt gebruikt. Dit is een mediatype voor het weergeven van resources en hun relaties via hyperlinks.  Deze API is vooral gericht op individuele bevragingen (op basis van de identificerende gegevens van een object). Om gebruik te kunnen maken van de BAG API is een API key nodig, deze kan verkregen worden door het [aanvraagformulier](https://formulieren.kadaster.nl/aanvraag_bag_api_individuele_bevragingen_productie) in te vullen.  Voor vragen, neem contact op met de LVBAG beheerder o.v.v. BAG API 2.0. We zijn aan het kijken naar een geschikt medium hiervoor, mede ook om de API iteratief te kunnen opstellen of doorontwikkelen samen met de community. Als de API iets (nog) niet kan, wat u wel graag wilt, neem dan contact op.
 *
 * OpenAPI spec version: 2.9.2
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.54
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Kadaster\BagApiClient\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Kadaster\BagApiClient\ApiException;
use Kadaster\BagApiClient\Configuration;
use Kadaster\BagApiClient\HeaderSelector;
use Kadaster\BagApiClient\ObjectSerializer;

/**
 * PandApi Class Doc Comment
 *
 * @category Class
 * @package  Kadaster\BagApiClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class PandApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation pandGeometrie
     *
     * bevragen panden met een geometrische locatie.
     *
     * @param  \Kadaster\BagApiClient\Model\PointGeoJSON $body Geometrisch punt waarop de panden bepaald moeten worden. (required)
     * @param  string $content_crs CRS van de meegegeven geometrie. (optional)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     * @param  \DateTime $geldig_op Filtert op objecten die geldig zijn op de opgegeven datum &#x60;JJJJ-MM-DD&#x60; Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  \DateTime $beschikbaar_op Filtert op objecten die beschikbaar zijn op de opgegeven datum en tijd  &#x60;YYYY-MM-DDThh:mm:ss.sss&#x27;. Hierin kunnen de seconden &#x27;:ss&#x27; en milliseconden  &#x27;.sss&#x27; of alleen de milliseconden conform ISO 8601 specificatie worden  weggelaten, in dat geval krijgen deze automatisch de waarde &#x27;:00&#x27;  respectievelijk &#x27;.000&#x27;. Indien er voor de milliseconden &#x27;.sss&#x27; meer dan 3  cijfers worden opgegeven, bv. &#x27;.12345&#x27;, dan wordt dit afgekapt tot &#x27;.123&#x27;. Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  bool $huidig Indicatie dat alleen actuele object voorkomens zonder eindstatus gewenst zijn. (optional, default to false)
     *
     * @throws \Kadaster\BagApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Kadaster\BagApiClient\Model\PandIOHalCollection
     */
    public function pandGeometrie($body, $content_crs = null, $accept_crs = null, $geldig_op = null, $beschikbaar_op = null, $huidig = 'false')
    {
        list($response) = $this->pandGeometrieWithHttpInfo($body, $content_crs, $accept_crs, $geldig_op, $beschikbaar_op, $huidig);
        return $response;
    }

    /**
     * Operation pandGeometrieWithHttpInfo
     *
     * bevragen panden met een geometrische locatie.
     *
     * @param  \Kadaster\BagApiClient\Model\PointGeoJSON $body Geometrisch punt waarop de panden bepaald moeten worden. (required)
     * @param  string $content_crs CRS van de meegegeven geometrie. (optional)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     * @param  \DateTime $geldig_op Filtert op objecten die geldig zijn op de opgegeven datum &#x60;JJJJ-MM-DD&#x60; Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  \DateTime $beschikbaar_op Filtert op objecten die beschikbaar zijn op de opgegeven datum en tijd  &#x60;YYYY-MM-DDThh:mm:ss.sss&#x27;. Hierin kunnen de seconden &#x27;:ss&#x27; en milliseconden  &#x27;.sss&#x27; of alleen de milliseconden conform ISO 8601 specificatie worden  weggelaten, in dat geval krijgen deze automatisch de waarde &#x27;:00&#x27;  respectievelijk &#x27;.000&#x27;. Indien er voor de milliseconden &#x27;.sss&#x27; meer dan 3  cijfers worden opgegeven, bv. &#x27;.12345&#x27;, dan wordt dit afgekapt tot &#x27;.123&#x27;. Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  bool $huidig Indicatie dat alleen actuele object voorkomens zonder eindstatus gewenst zijn. (optional, default to false)
     *
     * @throws \Kadaster\BagApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Kadaster\BagApiClient\Model\PandIOHalCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function pandGeometrieWithHttpInfo($body, $content_crs = null, $accept_crs = null, $geldig_op = null, $beschikbaar_op = null, $huidig = 'false')
    {
        $returnType = '\Kadaster\BagApiClient\Model\PandIOHalCollection';
        $request = $this->pandGeometrieRequest($body, $content_crs, $accept_crs, $geldig_op, $beschikbaar_op, $huidig);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\PandIOHalCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 412:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\ExtendedProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pandGeometrieAsync
     *
     * bevragen panden met een geometrische locatie.
     *
     * @param  \Kadaster\BagApiClient\Model\PointGeoJSON $body Geometrisch punt waarop de panden bepaald moeten worden. (required)
     * @param  string $content_crs CRS van de meegegeven geometrie. (optional)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     * @param  \DateTime $geldig_op Filtert op objecten die geldig zijn op de opgegeven datum &#x60;JJJJ-MM-DD&#x60; Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  \DateTime $beschikbaar_op Filtert op objecten die beschikbaar zijn op de opgegeven datum en tijd  &#x60;YYYY-MM-DDThh:mm:ss.sss&#x27;. Hierin kunnen de seconden &#x27;:ss&#x27; en milliseconden  &#x27;.sss&#x27; of alleen de milliseconden conform ISO 8601 specificatie worden  weggelaten, in dat geval krijgen deze automatisch de waarde &#x27;:00&#x27;  respectievelijk &#x27;.000&#x27;. Indien er voor de milliseconden &#x27;.sss&#x27; meer dan 3  cijfers worden opgegeven, bv. &#x27;.12345&#x27;, dan wordt dit afgekapt tot &#x27;.123&#x27;. Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  bool $huidig Indicatie dat alleen actuele object voorkomens zonder eindstatus gewenst zijn. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pandGeometrieAsync($body, $content_crs = null, $accept_crs = null, $geldig_op = null, $beschikbaar_op = null, $huidig = 'false')
    {
        return $this->pandGeometrieAsyncWithHttpInfo($body, $content_crs, $accept_crs, $geldig_op, $beschikbaar_op, $huidig)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pandGeometrieAsyncWithHttpInfo
     *
     * bevragen panden met een geometrische locatie.
     *
     * @param  \Kadaster\BagApiClient\Model\PointGeoJSON $body Geometrisch punt waarop de panden bepaald moeten worden. (required)
     * @param  string $content_crs CRS van de meegegeven geometrie. (optional)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     * @param  \DateTime $geldig_op Filtert op objecten die geldig zijn op de opgegeven datum &#x60;JJJJ-MM-DD&#x60; Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  \DateTime $beschikbaar_op Filtert op objecten die beschikbaar zijn op de opgegeven datum en tijd  &#x60;YYYY-MM-DDThh:mm:ss.sss&#x27;. Hierin kunnen de seconden &#x27;:ss&#x27; en milliseconden  &#x27;.sss&#x27; of alleen de milliseconden conform ISO 8601 specificatie worden  weggelaten, in dat geval krijgen deze automatisch de waarde &#x27;:00&#x27;  respectievelijk &#x27;.000&#x27;. Indien er voor de milliseconden &#x27;.sss&#x27; meer dan 3  cijfers worden opgegeven, bv. &#x27;.12345&#x27;, dan wordt dit afgekapt tot &#x27;.123&#x27;. Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  bool $huidig Indicatie dat alleen actuele object voorkomens zonder eindstatus gewenst zijn. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pandGeometrieAsyncWithHttpInfo($body, $content_crs = null, $accept_crs = null, $geldig_op = null, $beschikbaar_op = null, $huidig = 'false')
    {
        $returnType = '\Kadaster\BagApiClient\Model\PandIOHalCollection';
        $request = $this->pandGeometrieRequest($body, $content_crs, $accept_crs, $geldig_op, $beschikbaar_op, $huidig);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pandGeometrie'
     *
     * @param  \Kadaster\BagApiClient\Model\PointGeoJSON $body Geometrisch punt waarop de panden bepaald moeten worden. (required)
     * @param  string $content_crs CRS van de meegegeven geometrie. (optional)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     * @param  \DateTime $geldig_op Filtert op objecten die geldig zijn op de opgegeven datum &#x60;JJJJ-MM-DD&#x60; Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  \DateTime $beschikbaar_op Filtert op objecten die beschikbaar zijn op de opgegeven datum en tijd  &#x60;YYYY-MM-DDThh:mm:ss.sss&#x27;. Hierin kunnen de seconden &#x27;:ss&#x27; en milliseconden  &#x27;.sss&#x27; of alleen de milliseconden conform ISO 8601 specificatie worden  weggelaten, in dat geval krijgen deze automatisch de waarde &#x27;:00&#x27;  respectievelijk &#x27;.000&#x27;. Indien er voor de milliseconden &#x27;.sss&#x27; meer dan 3  cijfers worden opgegeven, bv. &#x27;.12345&#x27;, dan wordt dit afgekapt tot &#x27;.123&#x27;. Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  bool $huidig Indicatie dat alleen actuele object voorkomens zonder eindstatus gewenst zijn. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pandGeometrieRequest($body, $content_crs = null, $accept_crs = null, $geldig_op = null, $beschikbaar_op = null, $huidig = 'false')
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling pandGeometrie'
            );
        }

        $resourcePath = '/panden';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($geldig_op !== null) {
            $queryParams['geldigOp'] = ObjectSerializer::toQueryValue($geldig_op, 'date');
        }
        // query params
        if ($beschikbaar_op !== null) {
            $queryParams['beschikbaarOp'] = ObjectSerializer::toQueryValue($beschikbaar_op, 'date-time');
        }
        // query params
        if ($huidig !== null) {
            $queryParams['huidig'] = ObjectSerializer::toQueryValue($huidig, null);
        }
        // header params
        if ($content_crs !== null) {
            $headerParams['Content-Crs'] = ObjectSerializer::toHeaderValue($content_crs);
        }
        // header params
        if ($accept_crs !== null) {
            $headerParams['Accept-Crs'] = ObjectSerializer::toHeaderValue($accept_crs);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/hal+json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/hal+json', 'application/problem+json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pandIdentificatie
     *
     * bevragen van een pand met de identificatie van een pand.
     *
     * @param  \Kadaster\BagApiClient\Model\PandIdentificatie $identificatie De identificatie van een pand uit de BAG. (required)
     * @param  \DateTime $geldig_op Filtert op objecten die geldig zijn op de opgegeven datum &#x60;JJJJ-MM-DD&#x60; Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  \DateTime $beschikbaar_op Filtert op objecten die beschikbaar zijn op de opgegeven datum en tijd  &#x60;YYYY-MM-DDThh:mm:ss.sss&#x27;. Hierin kunnen de seconden &#x27;:ss&#x27; en milliseconden  &#x27;.sss&#x27; of alleen de milliseconden conform ISO 8601 specificatie worden  weggelaten, in dat geval krijgen deze automatisch de waarde &#x27;:00&#x27;  respectievelijk &#x27;.000&#x27;. Indien er voor de milliseconden &#x27;.sss&#x27; meer dan 3  cijfers worden opgegeven, bv. &#x27;.12345&#x27;, dan wordt dit afgekapt tot &#x27;.123&#x27;. Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     * @param  bool $huidig Indicatie dat alleen actuele object voorkomens zonder eindstatus gewenst zijn. (optional, default to false)
     *
     * @throws \Kadaster\BagApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Kadaster\BagApiClient\Model\PandIOHal
     */
    public function pandIdentificatie($identificatie, $geldig_op = null, $beschikbaar_op = null, $accept_crs = null, $huidig = 'false')
    {
        list($response) = $this->pandIdentificatieWithHttpInfo($identificatie, $geldig_op, $beschikbaar_op, $accept_crs, $huidig);
        return $response;
    }

    /**
     * Operation pandIdentificatieWithHttpInfo
     *
     * bevragen van een pand met de identificatie van een pand.
     *
     * @param  \Kadaster\BagApiClient\Model\PandIdentificatie $identificatie De identificatie van een pand uit de BAG. (required)
     * @param  \DateTime $geldig_op Filtert op objecten die geldig zijn op de opgegeven datum &#x60;JJJJ-MM-DD&#x60; Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  \DateTime $beschikbaar_op Filtert op objecten die beschikbaar zijn op de opgegeven datum en tijd  &#x60;YYYY-MM-DDThh:mm:ss.sss&#x27;. Hierin kunnen de seconden &#x27;:ss&#x27; en milliseconden  &#x27;.sss&#x27; of alleen de milliseconden conform ISO 8601 specificatie worden  weggelaten, in dat geval krijgen deze automatisch de waarde &#x27;:00&#x27;  respectievelijk &#x27;.000&#x27;. Indien er voor de milliseconden &#x27;.sss&#x27; meer dan 3  cijfers worden opgegeven, bv. &#x27;.12345&#x27;, dan wordt dit afgekapt tot &#x27;.123&#x27;. Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     * @param  bool $huidig Indicatie dat alleen actuele object voorkomens zonder eindstatus gewenst zijn. (optional, default to false)
     *
     * @throws \Kadaster\BagApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Kadaster\BagApiClient\Model\PandIOHal, HTTP status code, HTTP response headers (array of strings)
     */
    public function pandIdentificatieWithHttpInfo($identificatie, $geldig_op = null, $beschikbaar_op = null, $accept_crs = null, $huidig = 'false')
    {
        $returnType = '\Kadaster\BagApiClient\Model\PandIOHal';
        $request = $this->pandIdentificatieRequest($identificatie, $geldig_op, $beschikbaar_op, $accept_crs, $huidig);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\PandIOHal',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 412:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\ExtendedProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pandIdentificatieAsync
     *
     * bevragen van een pand met de identificatie van een pand.
     *
     * @param  \Kadaster\BagApiClient\Model\PandIdentificatie $identificatie De identificatie van een pand uit de BAG. (required)
     * @param  \DateTime $geldig_op Filtert op objecten die geldig zijn op de opgegeven datum &#x60;JJJJ-MM-DD&#x60; Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  \DateTime $beschikbaar_op Filtert op objecten die beschikbaar zijn op de opgegeven datum en tijd  &#x60;YYYY-MM-DDThh:mm:ss.sss&#x27;. Hierin kunnen de seconden &#x27;:ss&#x27; en milliseconden  &#x27;.sss&#x27; of alleen de milliseconden conform ISO 8601 specificatie worden  weggelaten, in dat geval krijgen deze automatisch de waarde &#x27;:00&#x27;  respectievelijk &#x27;.000&#x27;. Indien er voor de milliseconden &#x27;.sss&#x27; meer dan 3  cijfers worden opgegeven, bv. &#x27;.12345&#x27;, dan wordt dit afgekapt tot &#x27;.123&#x27;. Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     * @param  bool $huidig Indicatie dat alleen actuele object voorkomens zonder eindstatus gewenst zijn. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pandIdentificatieAsync($identificatie, $geldig_op = null, $beschikbaar_op = null, $accept_crs = null, $huidig = 'false')
    {
        return $this->pandIdentificatieAsyncWithHttpInfo($identificatie, $geldig_op, $beschikbaar_op, $accept_crs, $huidig)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pandIdentificatieAsyncWithHttpInfo
     *
     * bevragen van een pand met de identificatie van een pand.
     *
     * @param  \Kadaster\BagApiClient\Model\PandIdentificatie $identificatie De identificatie van een pand uit de BAG. (required)
     * @param  \DateTime $geldig_op Filtert op objecten die geldig zijn op de opgegeven datum &#x60;JJJJ-MM-DD&#x60; Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  \DateTime $beschikbaar_op Filtert op objecten die beschikbaar zijn op de opgegeven datum en tijd  &#x60;YYYY-MM-DDThh:mm:ss.sss&#x27;. Hierin kunnen de seconden &#x27;:ss&#x27; en milliseconden  &#x27;.sss&#x27; of alleen de milliseconden conform ISO 8601 specificatie worden  weggelaten, in dat geval krijgen deze automatisch de waarde &#x27;:00&#x27;  respectievelijk &#x27;.000&#x27;. Indien er voor de milliseconden &#x27;.sss&#x27; meer dan 3  cijfers worden opgegeven, bv. &#x27;.12345&#x27;, dan wordt dit afgekapt tot &#x27;.123&#x27;. Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     * @param  bool $huidig Indicatie dat alleen actuele object voorkomens zonder eindstatus gewenst zijn. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pandIdentificatieAsyncWithHttpInfo($identificatie, $geldig_op = null, $beschikbaar_op = null, $accept_crs = null, $huidig = 'false')
    {
        $returnType = '\Kadaster\BagApiClient\Model\PandIOHal';
        $request = $this->pandIdentificatieRequest($identificatie, $geldig_op, $beschikbaar_op, $accept_crs, $huidig);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pandIdentificatie'
     *
     * @param  \Kadaster\BagApiClient\Model\PandIdentificatie $identificatie De identificatie van een pand uit de BAG. (required)
     * @param  \DateTime $geldig_op Filtert op objecten die geldig zijn op de opgegeven datum &#x60;JJJJ-MM-DD&#x60; Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  \DateTime $beschikbaar_op Filtert op objecten die beschikbaar zijn op de opgegeven datum en tijd  &#x60;YYYY-MM-DDThh:mm:ss.sss&#x27;. Hierin kunnen de seconden &#x27;:ss&#x27; en milliseconden  &#x27;.sss&#x27; of alleen de milliseconden conform ISO 8601 specificatie worden  weggelaten, in dat geval krijgen deze automatisch de waarde &#x27;:00&#x27;  respectievelijk &#x27;.000&#x27;. Indien er voor de milliseconden &#x27;.sss&#x27; meer dan 3  cijfers worden opgegeven, bv. &#x27;.12345&#x27;, dan wordt dit afgekapt tot &#x27;.123&#x27;. Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     * @param  bool $huidig Indicatie dat alleen actuele object voorkomens zonder eindstatus gewenst zijn. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pandIdentificatieRequest($identificatie, $geldig_op = null, $beschikbaar_op = null, $accept_crs = null, $huidig = 'false')
    {
        // verify the required parameter 'identificatie' is set
        if ($identificatie === null || (is_array($identificatie) && count($identificatie) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identificatie when calling pandIdentificatie'
            );
        }

        $resourcePath = '/panden/{identificatie}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($geldig_op !== null) {
            $queryParams['geldigOp'] = ObjectSerializer::toQueryValue($geldig_op, 'date');
        }
        // query params
        if ($beschikbaar_op !== null) {
            $queryParams['beschikbaarOp'] = ObjectSerializer::toQueryValue($beschikbaar_op, 'date-time');
        }
        // query params
        if ($huidig !== null) {
            $queryParams['huidig'] = ObjectSerializer::toQueryValue($huidig, null);
        }
        // header params
        if ($accept_crs !== null) {
            $headerParams['Accept-Crs'] = ObjectSerializer::toHeaderValue($accept_crs);
        }

        // path params
        if ($identificatie !== null) {
            $resourcePath = str_replace(
                '{' . 'identificatie' . '}',
                ObjectSerializer::toPathValue($identificatie),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/hal+json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/hal+json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pandIdentificatieVoorkomen
     *
     * bevragen voorkomen van een pand met de identificatie van een pand en de identificatie van een voorkomen, bestaande uit een versie en een timestamp van het tijdstip van registratie in de LV BAG.
     *
     * @param  \Kadaster\BagApiClient\Model\PandIdentificatie $identificatie De identificatie van een pand uit de BAG. (required)
     * @param  int $versie De versie van een voorkomen van een object. (required)
     * @param  string $timestamp_registratie_lv Een timestamp van het tijdstip waarop een voorkomen is geregistreerd  in de LV BAG. (required)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     *
     * @throws \Kadaster\BagApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Kadaster\BagApiClient\Model\PandIOHal
     */
    public function pandIdentificatieVoorkomen($identificatie, $versie, $timestamp_registratie_lv, $accept_crs = null)
    {
        list($response) = $this->pandIdentificatieVoorkomenWithHttpInfo($identificatie, $versie, $timestamp_registratie_lv, $accept_crs);
        return $response;
    }

    /**
     * Operation pandIdentificatieVoorkomenWithHttpInfo
     *
     * bevragen voorkomen van een pand met de identificatie van een pand en de identificatie van een voorkomen, bestaande uit een versie en een timestamp van het tijdstip van registratie in de LV BAG.
     *
     * @param  \Kadaster\BagApiClient\Model\PandIdentificatie $identificatie De identificatie van een pand uit de BAG. (required)
     * @param  int $versie De versie van een voorkomen van een object. (required)
     * @param  string $timestamp_registratie_lv Een timestamp van het tijdstip waarop een voorkomen is geregistreerd  in de LV BAG. (required)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     *
     * @throws \Kadaster\BagApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Kadaster\BagApiClient\Model\PandIOHal, HTTP status code, HTTP response headers (array of strings)
     */
    public function pandIdentificatieVoorkomenWithHttpInfo($identificatie, $versie, $timestamp_registratie_lv, $accept_crs = null)
    {
        $returnType = '\Kadaster\BagApiClient\Model\PandIOHal';
        $request = $this->pandIdentificatieVoorkomenRequest($identificatie, $versie, $timestamp_registratie_lv, $accept_crs);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\PandIOHal',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 412:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\ExtendedProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pandIdentificatieVoorkomenAsync
     *
     * bevragen voorkomen van een pand met de identificatie van een pand en de identificatie van een voorkomen, bestaande uit een versie en een timestamp van het tijdstip van registratie in de LV BAG.
     *
     * @param  \Kadaster\BagApiClient\Model\PandIdentificatie $identificatie De identificatie van een pand uit de BAG. (required)
     * @param  int $versie De versie van een voorkomen van een object. (required)
     * @param  string $timestamp_registratie_lv Een timestamp van het tijdstip waarop een voorkomen is geregistreerd  in de LV BAG. (required)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pandIdentificatieVoorkomenAsync($identificatie, $versie, $timestamp_registratie_lv, $accept_crs = null)
    {
        return $this->pandIdentificatieVoorkomenAsyncWithHttpInfo($identificatie, $versie, $timestamp_registratie_lv, $accept_crs)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pandIdentificatieVoorkomenAsyncWithHttpInfo
     *
     * bevragen voorkomen van een pand met de identificatie van een pand en de identificatie van een voorkomen, bestaande uit een versie en een timestamp van het tijdstip van registratie in de LV BAG.
     *
     * @param  \Kadaster\BagApiClient\Model\PandIdentificatie $identificatie De identificatie van een pand uit de BAG. (required)
     * @param  int $versie De versie van een voorkomen van een object. (required)
     * @param  string $timestamp_registratie_lv Een timestamp van het tijdstip waarop een voorkomen is geregistreerd  in de LV BAG. (required)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pandIdentificatieVoorkomenAsyncWithHttpInfo($identificatie, $versie, $timestamp_registratie_lv, $accept_crs = null)
    {
        $returnType = '\Kadaster\BagApiClient\Model\PandIOHal';
        $request = $this->pandIdentificatieVoorkomenRequest($identificatie, $versie, $timestamp_registratie_lv, $accept_crs);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pandIdentificatieVoorkomen'
     *
     * @param  \Kadaster\BagApiClient\Model\PandIdentificatie $identificatie De identificatie van een pand uit de BAG. (required)
     * @param  int $versie De versie van een voorkomen van een object. (required)
     * @param  string $timestamp_registratie_lv Een timestamp van het tijdstip waarop een voorkomen is geregistreerd  in de LV BAG. (required)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pandIdentificatieVoorkomenRequest($identificatie, $versie, $timestamp_registratie_lv, $accept_crs = null)
    {
        // verify the required parameter 'identificatie' is set
        if ($identificatie === null || (is_array($identificatie) && count($identificatie) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identificatie when calling pandIdentificatieVoorkomen'
            );
        }
        // verify the required parameter 'versie' is set
        if ($versie === null || (is_array($versie) && count($versie) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $versie when calling pandIdentificatieVoorkomen'
            );
        }
        // verify the required parameter 'timestamp_registratie_lv' is set
        if ($timestamp_registratie_lv === null || (is_array($timestamp_registratie_lv) && count($timestamp_registratie_lv) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $timestamp_registratie_lv when calling pandIdentificatieVoorkomen'
            );
        }

        $resourcePath = '/panden/{identificatie}/{versie}/{timestampRegistratieLv}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_crs !== null) {
            $headerParams['Accept-Crs'] = ObjectSerializer::toHeaderValue($accept_crs);
        }

        // path params
        if ($identificatie !== null) {
            $resourcePath = str_replace(
                '{' . 'identificatie' . '}',
                ObjectSerializer::toPathValue($identificatie),
                $resourcePath
            );
        }
        // path params
        if ($versie !== null) {
            $resourcePath = str_replace(
                '{' . 'versie' . '}',
                ObjectSerializer::toPathValue($versie),
                $resourcePath
            );
        }
        // path params
        if ($timestamp_registratie_lv !== null) {
            $resourcePath = str_replace(
                '{' . 'timestampRegistratieLv' . '}',
                ObjectSerializer::toPathValue($timestamp_registratie_lv),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/hal+json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/hal+json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pandLvcIdentificatie
     *
     * bevragen levenscyclus van een pand met de identificatie van een pand.
     *
     * @param  \Kadaster\BagApiClient\Model\PandIdentificatie $identificatie De identificatie van een pand uit de BAG. (required)
     * @param  bool $gehele_lvc Filtert naast geldige voorkomens ook de voorkomens die uit de geldige levenscyclus van het object zijn verwijderd. Als deze parameter wordt weggelaten worden alleen geldige voorkomens geretourneerd (default is false). (optional, default to false)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     *
     * @throws \Kadaster\BagApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Kadaster\BagApiClient\Model\PandIOLvcHalCollection
     */
    public function pandLvcIdentificatie($identificatie, $gehele_lvc = 'false', $accept_crs = null)
    {
        list($response) = $this->pandLvcIdentificatieWithHttpInfo($identificatie, $gehele_lvc, $accept_crs);
        return $response;
    }

    /**
     * Operation pandLvcIdentificatieWithHttpInfo
     *
     * bevragen levenscyclus van een pand met de identificatie van een pand.
     *
     * @param  \Kadaster\BagApiClient\Model\PandIdentificatie $identificatie De identificatie van een pand uit de BAG. (required)
     * @param  bool $gehele_lvc Filtert naast geldige voorkomens ook de voorkomens die uit de geldige levenscyclus van het object zijn verwijderd. Als deze parameter wordt weggelaten worden alleen geldige voorkomens geretourneerd (default is false). (optional, default to false)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     *
     * @throws \Kadaster\BagApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Kadaster\BagApiClient\Model\PandIOLvcHalCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function pandLvcIdentificatieWithHttpInfo($identificatie, $gehele_lvc = 'false', $accept_crs = null)
    {
        $returnType = '\Kadaster\BagApiClient\Model\PandIOLvcHalCollection';
        $request = $this->pandLvcIdentificatieRequest($identificatie, $gehele_lvc, $accept_crs);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\PandIOLvcHalCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 412:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\ExtendedProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pandLvcIdentificatieAsync
     *
     * bevragen levenscyclus van een pand met de identificatie van een pand.
     *
     * @param  \Kadaster\BagApiClient\Model\PandIdentificatie $identificatie De identificatie van een pand uit de BAG. (required)
     * @param  bool $gehele_lvc Filtert naast geldige voorkomens ook de voorkomens die uit de geldige levenscyclus van het object zijn verwijderd. Als deze parameter wordt weggelaten worden alleen geldige voorkomens geretourneerd (default is false). (optional, default to false)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pandLvcIdentificatieAsync($identificatie, $gehele_lvc = 'false', $accept_crs = null)
    {
        return $this->pandLvcIdentificatieAsyncWithHttpInfo($identificatie, $gehele_lvc, $accept_crs)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pandLvcIdentificatieAsyncWithHttpInfo
     *
     * bevragen levenscyclus van een pand met de identificatie van een pand.
     *
     * @param  \Kadaster\BagApiClient\Model\PandIdentificatie $identificatie De identificatie van een pand uit de BAG. (required)
     * @param  bool $gehele_lvc Filtert naast geldige voorkomens ook de voorkomens die uit de geldige levenscyclus van het object zijn verwijderd. Als deze parameter wordt weggelaten worden alleen geldige voorkomens geretourneerd (default is false). (optional, default to false)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pandLvcIdentificatieAsyncWithHttpInfo($identificatie, $gehele_lvc = 'false', $accept_crs = null)
    {
        $returnType = '\Kadaster\BagApiClient\Model\PandIOLvcHalCollection';
        $request = $this->pandLvcIdentificatieRequest($identificatie, $gehele_lvc, $accept_crs);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pandLvcIdentificatie'
     *
     * @param  \Kadaster\BagApiClient\Model\PandIdentificatie $identificatie De identificatie van een pand uit de BAG. (required)
     * @param  bool $gehele_lvc Filtert naast geldige voorkomens ook de voorkomens die uit de geldige levenscyclus van het object zijn verwijderd. Als deze parameter wordt weggelaten worden alleen geldige voorkomens geretourneerd (default is false). (optional, default to false)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pandLvcIdentificatieRequest($identificatie, $gehele_lvc = 'false', $accept_crs = null)
    {
        // verify the required parameter 'identificatie' is set
        if ($identificatie === null || (is_array($identificatie) && count($identificatie) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identificatie when calling pandLvcIdentificatie'
            );
        }

        $resourcePath = '/panden/{identificatie}/lvc';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($gehele_lvc !== null) {
            $queryParams['geheleLvc'] = ObjectSerializer::toQueryValue($gehele_lvc, null);
        }
        // header params
        if ($accept_crs !== null) {
            $headerParams['Accept-Crs'] = ObjectSerializer::toHeaderValue($accept_crs);
        }

        // path params
        if ($identificatie !== null) {
            $resourcePath = str_replace(
                '{' . 'identificatie' . '}',
                ObjectSerializer::toPathValue($identificatie),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/hal+json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/hal+json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation zoekPanden
     *
     * Zoek panden met een geometrische locatie, binnen een bounding box,  met een adresseerbaar object identificatie of met een nummeraanduiding  identificatie.
     *
     * @param  \DateTime $geldig_op Filtert op objecten die geldig zijn op de opgegeven datum &#x60;JJJJ-MM-DD&#x60; Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  \DateTime $beschikbaar_op Filtert op objecten die beschikbaar zijn op de opgegeven datum en tijd  &#x60;YYYY-MM-DDThh:mm:ss.sss&#x27;. Hierin kunnen de seconden &#x27;:ss&#x27; en milliseconden  &#x27;.sss&#x27; of alleen de milliseconden conform ISO 8601 specificatie worden  weggelaten, in dat geval krijgen deze automatisch de waarde &#x27;:00&#x27;  respectievelijk &#x27;.000&#x27;. Indien er voor de milliseconden &#x27;.sss&#x27; meer dan 3  cijfers worden opgegeven, bv. &#x27;.12345&#x27;, dan wordt dit afgekapt tot &#x27;.123&#x27;. Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  bool $huidig Indicatie dat alleen actuele object voorkomens zonder eindstatus gewenst zijn. (optional, default to false)
     * @param  string $content_crs CRS van de meegegeven geometrie. (optional)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     * @param  int $page Pagina nummer (optional, default to 1)
     * @param  int $page_size Aantal resultaten per pagina (optional, default to 20)
     * @param  \Kadaster\BagApiClient\Model\PointGeoJSON $point Punt conform OGC API Features standaard. Met de content-crs header wordt aangegeven in welk CRS de coördinaten van het punt is. (optional)
     * @param  float[] $bbox Rechthoek (bounding box) waarbinnen het object dat je zoekt valt. Voor een definitie van bbox, zie [OGC API Features specificatie - bbox definitie](https://docs.opengeospatial.org/is/17-069r3/17-069r3.html#ats_core_fc-bbox-definition). Met de content-crs header wordt aangegeven in welk CRS de coördinaten van de bbox zijn.  Coördinaten worden als volgt opgegeven: linksonder x, linksonder y, rechtsboven x, rechtsboven y. De oppervlakte van de bounding box mag maximaal 250.000 vierkante meter zijn. (optional)
     * @param  \Kadaster\BagApiClient\Model\StatusPand[] $status_pand Status van het pand. (optional)
     * @param  bool $geconstateerd Geeft aan of naar geconstateerde objecten moet worden gezocht. (optional)
     * @param  int $bouwjaar_min bouwjaar_min (optional)
     * @param  int $bouwjaar_max bouwjaar_max (optional)
     * @param  \Kadaster\BagApiClient\Model\AdresseerbaarObjectIdentificatie $adresseerbaar_object_identificatie Identificatie van een adresseerbaar object uit de BAG. (optional)
     * @param  \Kadaster\BagApiClient\Model\NummeraanduidingIdentificatie $nummeraanduiding_identificatie De identificatie van een nummeraanduiding uit de BAG. (optional)
     *
     * @throws \Kadaster\BagApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Kadaster\BagApiClient\Model\PandIOHalCollection
     */
    public function zoekPanden($geldig_op = null, $beschikbaar_op = null, $huidig = 'false', $content_crs = null, $accept_crs = null, $page = '1', $page_size = '20', $point = null, $bbox = null, $status_pand = null, $geconstateerd = null, $bouwjaar_min = null, $bouwjaar_max = null, $adresseerbaar_object_identificatie = null, $nummeraanduiding_identificatie = null)
    {
        list($response) = $this->zoekPandenWithHttpInfo($geldig_op, $beschikbaar_op, $huidig, $content_crs, $accept_crs, $page, $page_size, $point, $bbox, $status_pand, $geconstateerd, $bouwjaar_min, $bouwjaar_max, $adresseerbaar_object_identificatie, $nummeraanduiding_identificatie);
        return $response;
    }

    /**
     * Operation zoekPandenWithHttpInfo
     *
     * Zoek panden met een geometrische locatie, binnen een bounding box,  met een adresseerbaar object identificatie of met een nummeraanduiding  identificatie.
     *
     * @param  \DateTime $geldig_op Filtert op objecten die geldig zijn op de opgegeven datum &#x60;JJJJ-MM-DD&#x60; Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  \DateTime $beschikbaar_op Filtert op objecten die beschikbaar zijn op de opgegeven datum en tijd  &#x60;YYYY-MM-DDThh:mm:ss.sss&#x27;. Hierin kunnen de seconden &#x27;:ss&#x27; en milliseconden  &#x27;.sss&#x27; of alleen de milliseconden conform ISO 8601 specificatie worden  weggelaten, in dat geval krijgen deze automatisch de waarde &#x27;:00&#x27;  respectievelijk &#x27;.000&#x27;. Indien er voor de milliseconden &#x27;.sss&#x27; meer dan 3  cijfers worden opgegeven, bv. &#x27;.12345&#x27;, dan wordt dit afgekapt tot &#x27;.123&#x27;. Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  bool $huidig Indicatie dat alleen actuele object voorkomens zonder eindstatus gewenst zijn. (optional, default to false)
     * @param  string $content_crs CRS van de meegegeven geometrie. (optional)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     * @param  int $page Pagina nummer (optional, default to 1)
     * @param  int $page_size Aantal resultaten per pagina (optional, default to 20)
     * @param  \Kadaster\BagApiClient\Model\PointGeoJSON $point Punt conform OGC API Features standaard. Met de content-crs header wordt aangegeven in welk CRS de coördinaten van het punt is. (optional)
     * @param  float[] $bbox Rechthoek (bounding box) waarbinnen het object dat je zoekt valt. Voor een definitie van bbox, zie [OGC API Features specificatie - bbox definitie](https://docs.opengeospatial.org/is/17-069r3/17-069r3.html#ats_core_fc-bbox-definition). Met de content-crs header wordt aangegeven in welk CRS de coördinaten van de bbox zijn.  Coördinaten worden als volgt opgegeven: linksonder x, linksonder y, rechtsboven x, rechtsboven y. De oppervlakte van de bounding box mag maximaal 250.000 vierkante meter zijn. (optional)
     * @param  \Kadaster\BagApiClient\Model\StatusPand[] $status_pand Status van het pand. (optional)
     * @param  bool $geconstateerd Geeft aan of naar geconstateerde objecten moet worden gezocht. (optional)
     * @param  int $bouwjaar_min (optional)
     * @param  int $bouwjaar_max (optional)
     * @param  \Kadaster\BagApiClient\Model\AdresseerbaarObjectIdentificatie $adresseerbaar_object_identificatie Identificatie van een adresseerbaar object uit de BAG. (optional)
     * @param  \Kadaster\BagApiClient\Model\NummeraanduidingIdentificatie $nummeraanduiding_identificatie De identificatie van een nummeraanduiding uit de BAG. (optional)
     *
     * @throws \Kadaster\BagApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Kadaster\BagApiClient\Model\PandIOHalCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function zoekPandenWithHttpInfo($geldig_op = null, $beschikbaar_op = null, $huidig = 'false', $content_crs = null, $accept_crs = null, $page = '1', $page_size = '20', $point = null, $bbox = null, $status_pand = null, $geconstateerd = null, $bouwjaar_min = null, $bouwjaar_max = null, $adresseerbaar_object_identificatie = null, $nummeraanduiding_identificatie = null)
    {
        $returnType = '\Kadaster\BagApiClient\Model\PandIOHalCollection';
        $request = $this->zoekPandenRequest($geldig_op, $beschikbaar_op, $huidig, $content_crs, $accept_crs, $page, $page_size, $point, $bbox, $status_pand, $geconstateerd, $bouwjaar_min, $bouwjaar_max, $adresseerbaar_object_identificatie, $nummeraanduiding_identificatie);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\PandIOHalCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 412:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\ExtendedProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kadaster\BagApiClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation zoekPandenAsync
     *
     * Zoek panden met een geometrische locatie, binnen een bounding box,  met een adresseerbaar object identificatie of met een nummeraanduiding  identificatie.
     *
     * @param  \DateTime $geldig_op Filtert op objecten die geldig zijn op de opgegeven datum &#x60;JJJJ-MM-DD&#x60; Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  \DateTime $beschikbaar_op Filtert op objecten die beschikbaar zijn op de opgegeven datum en tijd  &#x60;YYYY-MM-DDThh:mm:ss.sss&#x27;. Hierin kunnen de seconden &#x27;:ss&#x27; en milliseconden  &#x27;.sss&#x27; of alleen de milliseconden conform ISO 8601 specificatie worden  weggelaten, in dat geval krijgen deze automatisch de waarde &#x27;:00&#x27;  respectievelijk &#x27;.000&#x27;. Indien er voor de milliseconden &#x27;.sss&#x27; meer dan 3  cijfers worden opgegeven, bv. &#x27;.12345&#x27;, dan wordt dit afgekapt tot &#x27;.123&#x27;. Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  bool $huidig Indicatie dat alleen actuele object voorkomens zonder eindstatus gewenst zijn. (optional, default to false)
     * @param  string $content_crs CRS van de meegegeven geometrie. (optional)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     * @param  int $page Pagina nummer (optional, default to 1)
     * @param  int $page_size Aantal resultaten per pagina (optional, default to 20)
     * @param  \Kadaster\BagApiClient\Model\PointGeoJSON $point Punt conform OGC API Features standaard. Met de content-crs header wordt aangegeven in welk CRS de coördinaten van het punt is. (optional)
     * @param  float[] $bbox Rechthoek (bounding box) waarbinnen het object dat je zoekt valt. Voor een definitie van bbox, zie [OGC API Features specificatie - bbox definitie](https://docs.opengeospatial.org/is/17-069r3/17-069r3.html#ats_core_fc-bbox-definition). Met de content-crs header wordt aangegeven in welk CRS de coördinaten van de bbox zijn.  Coördinaten worden als volgt opgegeven: linksonder x, linksonder y, rechtsboven x, rechtsboven y. De oppervlakte van de bounding box mag maximaal 250.000 vierkante meter zijn. (optional)
     * @param  \Kadaster\BagApiClient\Model\StatusPand[] $status_pand Status van het pand. (optional)
     * @param  bool $geconstateerd Geeft aan of naar geconstateerde objecten moet worden gezocht. (optional)
     * @param  int $bouwjaar_min (optional)
     * @param  int $bouwjaar_max (optional)
     * @param  \Kadaster\BagApiClient\Model\AdresseerbaarObjectIdentificatie $adresseerbaar_object_identificatie Identificatie van een adresseerbaar object uit de BAG. (optional)
     * @param  \Kadaster\BagApiClient\Model\NummeraanduidingIdentificatie $nummeraanduiding_identificatie De identificatie van een nummeraanduiding uit de BAG. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function zoekPandenAsync($geldig_op = null, $beschikbaar_op = null, $huidig = 'false', $content_crs = null, $accept_crs = null, $page = '1', $page_size = '20', $point = null, $bbox = null, $status_pand = null, $geconstateerd = null, $bouwjaar_min = null, $bouwjaar_max = null, $adresseerbaar_object_identificatie = null, $nummeraanduiding_identificatie = null)
    {
        return $this->zoekPandenAsyncWithHttpInfo($geldig_op, $beschikbaar_op, $huidig, $content_crs, $accept_crs, $page, $page_size, $point, $bbox, $status_pand, $geconstateerd, $bouwjaar_min, $bouwjaar_max, $adresseerbaar_object_identificatie, $nummeraanduiding_identificatie)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation zoekPandenAsyncWithHttpInfo
     *
     * Zoek panden met een geometrische locatie, binnen een bounding box,  met een adresseerbaar object identificatie of met een nummeraanduiding  identificatie.
     *
     * @param  \DateTime $geldig_op Filtert op objecten die geldig zijn op de opgegeven datum &#x60;JJJJ-MM-DD&#x60; Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  \DateTime $beschikbaar_op Filtert op objecten die beschikbaar zijn op de opgegeven datum en tijd  &#x60;YYYY-MM-DDThh:mm:ss.sss&#x27;. Hierin kunnen de seconden &#x27;:ss&#x27; en milliseconden  &#x27;.sss&#x27; of alleen de milliseconden conform ISO 8601 specificatie worden  weggelaten, in dat geval krijgen deze automatisch de waarde &#x27;:00&#x27;  respectievelijk &#x27;.000&#x27;. Indien er voor de milliseconden &#x27;.sss&#x27; meer dan 3  cijfers worden opgegeven, bv. &#x27;.12345&#x27;, dan wordt dit afgekapt tot &#x27;.123&#x27;. Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  bool $huidig Indicatie dat alleen actuele object voorkomens zonder eindstatus gewenst zijn. (optional, default to false)
     * @param  string $content_crs CRS van de meegegeven geometrie. (optional)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     * @param  int $page Pagina nummer (optional, default to 1)
     * @param  int $page_size Aantal resultaten per pagina (optional, default to 20)
     * @param  \Kadaster\BagApiClient\Model\PointGeoJSON $point Punt conform OGC API Features standaard. Met de content-crs header wordt aangegeven in welk CRS de coördinaten van het punt is. (optional)
     * @param  float[] $bbox Rechthoek (bounding box) waarbinnen het object dat je zoekt valt. Voor een definitie van bbox, zie [OGC API Features specificatie - bbox definitie](https://docs.opengeospatial.org/is/17-069r3/17-069r3.html#ats_core_fc-bbox-definition). Met de content-crs header wordt aangegeven in welk CRS de coördinaten van de bbox zijn.  Coördinaten worden als volgt opgegeven: linksonder x, linksonder y, rechtsboven x, rechtsboven y. De oppervlakte van de bounding box mag maximaal 250.000 vierkante meter zijn. (optional)
     * @param  \Kadaster\BagApiClient\Model\StatusPand[] $status_pand Status van het pand. (optional)
     * @param  bool $geconstateerd Geeft aan of naar geconstateerde objecten moet worden gezocht. (optional)
     * @param  int $bouwjaar_min (optional)
     * @param  int $bouwjaar_max (optional)
     * @param  \Kadaster\BagApiClient\Model\AdresseerbaarObjectIdentificatie $adresseerbaar_object_identificatie Identificatie van een adresseerbaar object uit de BAG. (optional)
     * @param  \Kadaster\BagApiClient\Model\NummeraanduidingIdentificatie $nummeraanduiding_identificatie De identificatie van een nummeraanduiding uit de BAG. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function zoekPandenAsyncWithHttpInfo($geldig_op = null, $beschikbaar_op = null, $huidig = 'false', $content_crs = null, $accept_crs = null, $page = '1', $page_size = '20', $point = null, $bbox = null, $status_pand = null, $geconstateerd = null, $bouwjaar_min = null, $bouwjaar_max = null, $adresseerbaar_object_identificatie = null, $nummeraanduiding_identificatie = null)
    {
        $returnType = '\Kadaster\BagApiClient\Model\PandIOHalCollection';
        $request = $this->zoekPandenRequest($geldig_op, $beschikbaar_op, $huidig, $content_crs, $accept_crs, $page, $page_size, $point, $bbox, $status_pand, $geconstateerd, $bouwjaar_min, $bouwjaar_max, $adresseerbaar_object_identificatie, $nummeraanduiding_identificatie);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'zoekPanden'
     *
     * @param  \DateTime $geldig_op Filtert op objecten die geldig zijn op de opgegeven datum &#x60;JJJJ-MM-DD&#x60; Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  \DateTime $beschikbaar_op Filtert op objecten die beschikbaar zijn op de opgegeven datum en tijd  &#x60;YYYY-MM-DDThh:mm:ss.sss&#x27;. Hierin kunnen de seconden &#x27;:ss&#x27; en milliseconden  &#x27;.sss&#x27; of alleen de milliseconden conform ISO 8601 specificatie worden  weggelaten, in dat geval krijgen deze automatisch de waarde &#x27;:00&#x27;  respectievelijk &#x27;.000&#x27;. Indien er voor de milliseconden &#x27;.sss&#x27; meer dan 3  cijfers worden opgegeven, bv. &#x27;.12345&#x27;, dan wordt dit afgekapt tot &#x27;.123&#x27;. Deze parameter komt uit de API strategie, het hoofdstuk  [Temporal](https://docs.geostandaarden.nl/api/API-Strategie-ext/#temporal). (optional)
     * @param  bool $huidig Indicatie dat alleen actuele object voorkomens zonder eindstatus gewenst zijn. (optional, default to false)
     * @param  string $content_crs CRS van de meegegeven geometrie. (optional)
     * @param  string $accept_crs Gewenste CRS van de coördinaten in de response. (optional)
     * @param  int $page Pagina nummer (optional, default to 1)
     * @param  int $page_size Aantal resultaten per pagina (optional, default to 20)
     * @param  \Kadaster\BagApiClient\Model\PointGeoJSON $point Punt conform OGC API Features standaard. Met de content-crs header wordt aangegeven in welk CRS de coördinaten van het punt is. (optional)
     * @param  float[] $bbox Rechthoek (bounding box) waarbinnen het object dat je zoekt valt. Voor een definitie van bbox, zie [OGC API Features specificatie - bbox definitie](https://docs.opengeospatial.org/is/17-069r3/17-069r3.html#ats_core_fc-bbox-definition). Met de content-crs header wordt aangegeven in welk CRS de coördinaten van de bbox zijn.  Coördinaten worden als volgt opgegeven: linksonder x, linksonder y, rechtsboven x, rechtsboven y. De oppervlakte van de bounding box mag maximaal 250.000 vierkante meter zijn. (optional)
     * @param  \Kadaster\BagApiClient\Model\StatusPand[] $status_pand Status van het pand. (optional)
     * @param  bool $geconstateerd Geeft aan of naar geconstateerde objecten moet worden gezocht. (optional)
     * @param  int $bouwjaar_min (optional)
     * @param  int $bouwjaar_max (optional)
     * @param  \Kadaster\BagApiClient\Model\AdresseerbaarObjectIdentificatie $adresseerbaar_object_identificatie Identificatie van een adresseerbaar object uit de BAG. (optional)
     * @param  \Kadaster\BagApiClient\Model\NummeraanduidingIdentificatie $nummeraanduiding_identificatie De identificatie van een nummeraanduiding uit de BAG. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function zoekPandenRequest($geldig_op = null, $beschikbaar_op = null, $huidig = 'false', $content_crs = null, $accept_crs = null, $page = '1', $page_size = '20', $point = null, $bbox = null, $status_pand = null, $geconstateerd = null, $bouwjaar_min = null, $bouwjaar_max = null, $adresseerbaar_object_identificatie = null, $nummeraanduiding_identificatie = null)
    {

        $resourcePath = '/panden';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($geldig_op !== null) {
            $queryParams['geldigOp'] = ObjectSerializer::toQueryValue($geldig_op, 'date');
        }
        // query params
        if ($beschikbaar_op !== null) {
            $queryParams['beschikbaarOp'] = ObjectSerializer::toQueryValue($beschikbaar_op, 'date-time');
        }
        // query params
        if ($huidig !== null) {
            $queryParams['huidig'] = ObjectSerializer::toQueryValue($huidig, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, null);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size, null);
        }
        // query params
        if ($point !== null) {
            $queryParams['point'] = ObjectSerializer::toQueryValue($point, null);
        }
        // query params
        if (is_array($bbox)) {
            $bbox = ObjectSerializer::serializeCollection($bbox, 'csv', true);
        }
        if ($bbox !== null) {
            $queryParams['bbox'] = ObjectSerializer::toQueryValue($bbox, null);
        }
        // query params
        if (is_array($status_pand)) {
            $status_pand = ObjectSerializer::serializeCollection($status_pand, 'multi', true);
        }
        if ($status_pand !== null) {
            $queryParams['statusPand'] = ObjectSerializer::toQueryValue($status_pand, null);
        }
        // query params
        if ($geconstateerd !== null) {
            $queryParams['geconstateerd'] = ObjectSerializer::toQueryValue($geconstateerd, null);
        }
        // query params
        if ($bouwjaar_min !== null) {
            $queryParams['bouwjaar[min]'] = ObjectSerializer::toQueryValue($bouwjaar_min, null);
        }
        // query params
        if ($bouwjaar_max !== null) {
            $queryParams['bouwjaar[max]'] = ObjectSerializer::toQueryValue($bouwjaar_max, null);
        }
        // query params
        if ($adresseerbaar_object_identificatie !== null) {
            $queryParams['adresseerbaarObjectIdentificatie'] = ObjectSerializer::toQueryValue($adresseerbaar_object_identificatie, null);
        }
        // query params
        if ($nummeraanduiding_identificatie !== null) {
            $queryParams['nummeraanduidingIdentificatie'] = ObjectSerializer::toQueryValue($nummeraanduiding_identificatie, null);
        }
        // header params
        if ($content_crs !== null) {
            $headerParams['Content-Crs'] = ObjectSerializer::toHeaderValue($content_crs);
        }
        // header params
        if ($accept_crs !== null) {
            $headerParams['Accept-Crs'] = ObjectSerializer::toHeaderValue($accept_crs);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/hal+json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/hal+json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
